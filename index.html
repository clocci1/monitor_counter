<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Home — Import PI/WT</title>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <script src="./app-core.js"></script>

  <style>
    :root{
      --bg:#0b1220; --card:#111a2e; --border:rgba(255,255,255,.12);
      --muted:#a9b7d6; --text:#e8eefc; --btn:#6ea8fe; --bad:#ff6b6b; --ok:#5eead4;
    }
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);color:var(--text);}
    header{padding:14px 18px;border-bottom:1px solid var(--border);position:sticky;top:0;background:rgba(11,18,32,.92);backdrop-filter:blur(8px);z-index:5}
    nav a{color:var(--text);text-decoration:none;margin-right:12px;font-weight:900;}
    nav a.active{color:var(--btn);}
    .wrap{max-width:1400px;margin:0 auto;padding:16px 18px;}
    .layout{display:grid;grid-template-columns:1fr 420px;gap:12px;align-items:start;}
    @media(max-width:1100px){.layout{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;}
    .hint{color:var(--muted);font-size:12px;}
    .bad{color:var(--bad);}
    .ok{color:var(--ok);font-weight:900;}
    .mono{font-variant-numeric:tabular-nums;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end;}
    .col{display:flex;flex-direction:column;gap:6px;min-width:240px}
    input,select,button{border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);padding:10px;}
    button{background:var(--btn);color:var(--bg);border:0;font-weight:900;cursor:pointer;}
    button.secondary{background:rgba(255,255,255,.10);color:var(--text);border:1px solid var(--border);}
    button.danger{background:rgba(255,107,107,.20);color:var(--text);border:1px solid rgba(255,107,107,.45);}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:12px;}
    th,td{padding:8px;border-bottom:1px solid var(--border);vertical-align:top;}
    th{color:var(--muted);text-align:left;font-weight:900;}
    .sideHead{display:flex;align-items:center;justify-content:space-between;gap:8px;}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:rgba(255,255,255,.06);font-size:12px;}
    .dsTable th,.dsTable td{padding:7px 8px;}
    .tiny{font-size:11px;color:var(--muted);}
    .chk{transform:scale(1.05);}
  </style>
</head>

<body>
<header>
  <nav>
    <a class="active" href="index.html">Home</a>
    <a href="overview.html">Overview</a>
    <a href="charts.html">Charts</a>
    <a href="score.html">Score</a>
  </nav>
</header>

<div class="wrap">
  <div class="layout">
    <div>
      <div class="card">
        <div style="font-weight:900;">Import PI + WT → Supabase</div>
        <div class="hint" style="margin-top:4px;">Carica i file Excel (anche multipli). Lo script splitta automaticamente per giorno e aggiorna le tabelle <span class="mono">datasets</span> + <span class="mono">events</span>.</div>

        <div class="row" style="margin-top:12px;">
          <div class="col">
            <label class="hint">PI (uno o più file .xlsx)</label>
            <input id="piFile" type="file" accept=".xlsx,.xls" multiple />
          </div>
          <div class="col">
            <label class="hint">WT (uno o più file .xlsx)</label>
            <input id="wtFile" type="file" accept=".xlsx,.xls" multiple />
          </div>
          <div class="col" style="min-width:200px">
            <label class="hint">Formato nome dataset</label>
            <select id="labelFmt">
              <option value="dd-mm">dd-mm</option>
              <option value="dd-mm-yyyy" selected>dd-mm-yyyy</option>
            </select>
          </div>
          <div class="col" style="min-width:220px">
            <button id="analyzeBtn" type="button">Importa su Supabase</button>
          </div>
          <div class="col" style="min-width:220px">
            <button id="refreshBtn" class="secondary" type="button">Ricarica elenco</button>
          </div>
        </div>

        <div id="status" class="hint" style="margin-top:10px;">Stato: —</div>
        <div id="warn" class="hint" style="margin-top:6px;"></div>
        <div id="err" class="hint bad" style="margin-top:6px;"></div>
      </div>

      <div class="card" style="margin-top:12px;">
        <div style="font-weight:900;">Note di modello dati</div>
        <div class="hint" style="margin-top:6px;">
          <div>- Per WT salviamo <span class="mono">lane</span> dalla <span class="mono">Source Storage Bin</span>; per P2P (9994/9995) aggiungiamo anche una riga extra usando <span class="mono">Destination Storage Bin</span> (se presente) così la Heatmap Task per corsia è coerente.</div>
          <div>- Clean PICK include 3060/3062 + 3040/3041/3042.</div>
        </div>
      </div>
    </div>

    <aside class="side">
      <div class="card">
        <div class="sideHead">
          <strong>Dataset presenti</strong>
          <span id="selSummary" class="badge">0 selezionati</span>
        </div>

        <div class="row" style="margin-top:10px;align-items:center;">
          <div class="col" style="min-width:200px">
            <label class="hint">Selezione per</label>
            <select id="selMode">
              <option value="day" selected>Giorni</option>
              <option value="week">Settimane</option>
              <option value="month">Mesi</option>
            </select>
          </div>
          <div class="col" style="min-width:unset">
            <button id="selAllBtn" class="secondary" type="button">Tutti</button>
          </div>
          <div class="col" style="min-width:unset">
            <button id="sel7Btn" class="secondary" type="button">Ultimi 7</button>
          </div>
          <div class="col" style="min-width:unset">
            <button id="clearSelBtn" class="danger" type="button">Reset</button>
          </div>
        </div>

        <div class="hint" style="margin-top:8px;">Spunta PI/WT per definire periodo e cosa includere nell’analisi (la selezione è condivisa tra tutte le pagine).</div>
        <div id="dsWrap"></div>
      </div>
    </aside>
  </div>
</div>

<script>
  const Core = window.AppCore;
  const sb = Core.sb;
  const EVENTS_OPERATOR_COL = Core.EVENTS_OPERATOR_COL;
  const INTEREST_OPERATORS = Core.INTEREST_OPERATORS;

  const $ = (id)=>document.getElementById(id);
  function setStatus(t, ok=false){ $("status").innerHTML = `Stato: <span class="${ok?'ok':''}">${t}</span>`; }
  function setErr(t){ $("err").textContent = t||""; }
  function setWarn(t){ $("warn").innerHTML = t||""; }

  function dayKeyFromDate(dt){ return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`; }
  function fmtLabelFromDayKey(dayKey, fmt){
    const d = new Date(dayKey + "T00:00:00");
    if(isNaN(d.getTime())) return dayKey;
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yyyy = d.getFullYear();
    return (fmt === 'dd-mm') ? `${dd}-${mm}` : `${dd}-${mm}-${yyyy}`;
  }

  function parseTimeToHMS(t){
    if(t===null||t===undefined||t==="") return { h:0, min:0, s:0 };
    if(t instanceof Date && !isNaN(t.getTime())) return { h:t.getHours(), min:t.getMinutes(), s:t.getSeconds() };
    if(typeof t==="number" && isFinite(t)){
      const totalSeconds = Math.round(t*24*3600);
      return { h:Math.floor(totalSeconds/3600)%24, min:Math.floor((totalSeconds%3600)/60), s:totalSeconds%60 };
    }
    const s=String(t).trim();
    const m=s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if(m) return { h:+m[1], min:+m[2], s:m[3]?+m[3]:0 };
    const dt=new Date(s);
    if(!isNaN(dt.getTime())) return { h:dt.getHours(), min:dt.getMinutes(), s:dt.getSeconds() };
    return { h:0, min:0, s:0 };
  }
  function excelDateToYMD(d){
    if(!d) return null;
    if(d instanceof Date && !isNaN(d.getTime())) return { y:d.getFullYear(), m:d.getMonth()+1, day:d.getDate() };
    const dt=new Date(d);
    if(!isNaN(dt.getTime())) return { y:dt.getFullYear(), m:dt.getMonth()+1, day:dt.getDate() };
    return null;
  }
  function combineDateTime(dateVal, timeVal){
    const ymd=excelDateToYMD(dateVal);
    if(!ymd) return null;
    const hms=parseTimeToHMS(timeVal);
    const dt=new Date(ymd.y, ymd.m-1, ymd.day, hms.h, hms.min, hms.s);
    return isNaN(dt.getTime()) ? null : dt;
  }

  async function readFirstSheetAsObjects(file){
    const ab = await file.arrayBuffer();
    const wb = XLSX.read(ab, {type:"array", cellDates:true});
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, {defval:""});
  }

  // Selection bridging
  function getSel(){ return Core.getSelection(); }
  function setSel(s){ Core.setSelection(s); updateSelSummary(); }

  function updateSelSummary(){
    const sel = getSel();
    const mode = sel.mode || "day";
    const picked = (mode==="day")
      ? Object.entries(sel.days||{}).filter(([,v])=>v && (v.pi||v.wt)).length
      : (sel.groups||[]).length;
    $("selSummary").textContent = `${picked} selezionati`;
  }

  async function insertInChunks(table, rows, chunkSize=1000){
    for(let i=0;i<rows.length;i+=chunkSize){
      const chunk = rows.slice(i, i+chunkSize);
      const { error } = await sb.from(table).insert(chunk);
      if(error) throw new Error(error.message);
    }
  }

  async function upsertDatasetForDay(dayKey, label, piCount, wtCount){
    const payload = { day_key: dayKey, label, pi_rows: piCount, wt_rows: wtCount };
    const { data, error } = await sb
      .from('datasets')
      .upsert([payload], { onConflict: 'day_key' })
      .select()
      .single();
    if(error) throw new Error(error.message);
    return data;
  }
  async function deleteEventsForDataset(datasetId){
    const { error } = await sb.from('events').delete().eq('dataset_id', datasetId);
    if(error) throw new Error(error.message);
  }

  function groupRowsByDay(piRows, wtRows){
    const piByDay = new Map();
    const wtByDay = new Map();

    for(const r of (piRows||[])){
      const counter = Core.normStr(r["Counter"]);
      if(!INTEREST_OPERATORS.has(counter)) continue;
      const ts = combineDateTime(r["Count Date"], r["Count Time"]);
      if(!ts) continue;
      const dayKey = dayKeyFromDate(ts);
      if(!piByDay.has(dayKey)) piByDay.set(dayKey, []);
      piByDay.get(dayKey).push(r);
    }

    for(const r of (wtRows||[])){
      if(!Core.isNonEmptyBin(r["Source Storage Bin"])) continue;
      const createdBy = Core.normStr(r["Created By"]);
      const confirmedBy = Core.normStr(r["Confirmed by"]);
      const operator = confirmedBy || createdBy;
      if(!INTEREST_OPERATORS.has(operator)) continue;

      const dtVal = (r["Confirmation Date"] || r["Created On"]);
      const tmVal = (r["Confirmation Time"] || r["Created At"]);
      const ts = combineDateTime(dtVal, tmVal);
      if(!ts) continue;

      const dayKey = dayKeyFromDate(ts);
      if(!wtByDay.has(dayKey)) wtByDay.set(dayKey, []);
      wtByDay.get(dayKey).push(r);
    }

    const dayKeys = Array.from(new Set([ ...piByDay.keys(), ...wtByDay.keys() ])).sort();
    return { dayKeys, piByDay, wtByDay };
  }

  async function loadDatasets(){
    setErr(""); setWarn("");
    const data = await Core.fetchDatasets();
    const wrap = $("dsWrap");
    const sel = getSel();
    const mode = $("selMode").value || sel.mode || "day";
    sel.mode = mode;

    if(!data.length){
      wrap.innerHTML = `<div class="hint">Nessun dataset.</div>`;
      setSel(sel);
      return;
    }

    const allDayKeys = data.map(d=>d.day_key).filter(Boolean).sort();
    const byGroup = new Map();
    for(const dk of allDayKeys){
      const gk = Core.groupKey(dk, mode);
      byGroup.set(gk, (byGroup.get(gk)||[]).concat([dk]));
    }

    if(mode==="day"){
      const rows = data.map(d=>{
        const dk = d.day_key || "";
        const label = d.label || dk || "(senza label)";
        const created = d.created_at ? String(d.created_at).replace('T',' ').slice(0,19) : "";
        const piOk = (d.pi_rows||0) > 0;
        const wtOk = (d.wt_rows||0) > 0;
        const s = (sel.days||{})[dk] || { pi:false, wt:false };
        return `
          <tr>
            <td class="mono">${label}</td>
            <td class="mono tiny">${created}</td>
            <td style="text-align:center;"><input class="chk" type="checkbox" data-day="${dk}" data-kind="pi" ${s.pi?'checked':''} ${piOk?'':'disabled'} /></td>
            <td style="text-align:center;"><input class="chk" type="checkbox" data-day="${dk}" data-kind="wt" ${s.wt?'checked':''} ${wtOk?'':'disabled'} /></td>
          </tr>
        `;
      }).join("");

      wrap.innerHTML = `
        <table class="dsTable">
          <thead><tr><th>Date</th><th>Load Day</th><th style="text-align:center;">PI</th><th style="text-align:center;">WT</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      `;

      wrap.querySelectorAll('input[type="checkbox"][data-day]').forEach(chk=>{
        chk.addEventListener('change', ()=>{
          const day = chk.getAttribute('data-day');
          const kind = chk.getAttribute('data-kind');
          const sel2 = getSel();
          sel2.mode = "day";
          sel2.days = sel2.days || {};
          sel2.days[day] = sel2.days[day] || {pi:false,wt:false};
          sel2.days[day][kind] = chk.checked;
          if(!sel2.days[day].pi && !sel2.days[day].wt) delete sel2.days[day];
          setSel(sel2);
        });
      });
    }else{
      const groups = Array.from(byGroup.keys()).sort().reverse();
      const picked = new Set(sel.groups||[]);
      const rows = groups.map(gk=>{
        const dks = byGroup.get(gk) || [];
        const label = (mode==="month") ? gk : gk;
        const checked = picked.has(gk);
        return `
          <tr>
            <td class="mono">${label}</td>
            <td class="mono tiny">${dks.length} giorni</td>
            <td style="text-align:center;"><input class="chk" type="checkbox" data-g="${gk}" ${checked?'checked':''} /></td>
          </tr>
        `;
      }).join("");
      wrap.innerHTML = `
        <table class="dsTable">
          <thead><tr><th>${mode==="month"?"Mese": "Settimana"}</th><th>Copertura</th><th style="text-align:center;">Sel</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      `;
      wrap.querySelectorAll('input[type="checkbox"][data-g]').forEach(chk=>{
        chk.addEventListener('change', ()=>{
          const g = chk.getAttribute('data-g');
          const sel2 = getSel();
          sel2.mode = mode;
          sel2.groups = sel2.groups || [];
          const s = new Set(sel2.groups);
          if(chk.checked) s.add(g); else s.delete(g);
          sel2.groups = Array.from(s);
          // default: include both PI and WT for days in group (deciderai poi su Overview)
          sel2.days = sel2.days || {};
          // non forziamo; lasciamo vuoto: in pagine KPI useremo include PI/WT default true
          setSel(sel2);
        });
      });
    }

    $("selMode").value = mode;
    setSel(sel);
  }

  // quick selections (for day mode: last 7 days; for week/month: last 7 dayKeys mapped to groups)
  async function quickSelect(kind){
    const ds = await Core.fetchDatasets();
    const allDayKeys = ds.map(d=>d.day_key).filter(Boolean).sort();
    const sel = getSel();
    const mode = $("selMode").value || "day";
    sel.mode = mode;
    sel.days = {};
    sel.groups = [];
    if(kind==="clear"){
      setSel(sel);
      await loadDatasets();
      return;
    }
    const chosen = (kind==="all") ? allDayKeys : allDayKeys.slice(-7);
    if(mode==="day"){
      for(const dk of chosen) sel.days[dk] = { pi:true, wt:true };
    }else{
      const gset = new Set();
      for(const dk of chosen) gset.add(Core.groupKey(dk, mode));
      sel.groups = Array.from(gset);
    }
    setSel(sel);
    await loadDatasets();
  }

  $("selMode").addEventListener("change", loadDatasets);
  $("refreshBtn").addEventListener("click", loadDatasets);
  $("clearSelBtn").addEventListener("click", ()=>quickSelect("clear"));
  $("selAllBtn").addEventListener("click", ()=>quickSelect("all"));
  $("sel7Btn").addEventListener("click", ()=>quickSelect("7"));

  $("analyzeBtn").addEventListener("click", async ()=>{
    try{
      setErr(""); setWarn("");
      const piFiles = Array.from($("piFile").files||[]);
      const wtFiles = Array.from($("wtFile").files||[]);
      if(!piFiles.length || !wtFiles.length){
        setErr("Carica PI e WT (puoi selezionare anche più file per ciascun tipo).");
        return;
      }
      const labelFmt = $("labelFmt").value || 'dd-mm-yyyy';

      setStatus("Lettura Excel…");
      const piRowsAll = [];
      for(const f of piFiles){ piRowsAll.push(...await readFirstSheetAsObjects(f)); }
      const wtRowsAll = [];
      for(const f of wtFiles){ wtRowsAll.push(...await readFirstSheetAsObjects(f)); }

      setStatus("Analisi date (split per giorno)…");
      const { dayKeys, piByDay, wtByDay } = groupRowsByDay(piRowsAll, wtRowsAll);
      if(!dayKeys.length){
        setWarn("Nessun evento per gli operatori filtrati o date non valide nei file.");
        setStatus("Pronto.");
        return;
      }

      let totalInserted=0;

      for(const dayKey of dayKeys){
        const piRows = piByDay.get(dayKey) || [];
        const wtRows = wtByDay.get(dayKey) || [];
        const label = fmtLabelFromDayKey(dayKey, labelFmt);

        setStatus(`Upsert dataset ${label}…`);
        const ds = await upsertDatasetForDay(dayKey, label, piRows.length, wtRows.length);
        const datasetId = ds.id;

        setStatus(`Pulizia eventi esistenti (${label})…`);
        await deleteEventsForDataset(datasetId);

        setStatus(`Normalizzazione eventi (${label})…`);
        const events = [];

        // PI
        for(const r of piRows){
          const counter = Core.normStr(r["Counter"]);
          if(!INTEREST_OPERATORS.has(counter)) continue;
          const ts = combineDateTime(r["Count Date"], r["Count Time"]);
          if(!ts) continue;

          const createdBy = Core.normStr(r["Created By"]);
          const storageBin = Core.normStr(r["Storage Bin"]);
          const category = Core.piCategory(storageBin);
          const lane = Core.laneFromStorageBin(storageBin);

          events.push({
            dataset_id: datasetId,
            ts: ts.toISOString(),
            day_key: dayKey,
            [EVENTS_OPERATOR_COL]: counter,
            kind: "PI",
            category,
            self_count: (counter && counter===createdBy),
            storage_bin: storageBin || null,
            lane: (lane===null ? null : lane),
            wo_id: null
          });
        }

        // WT
        for(const r of wtRows){
          if(!Core.isNonEmptyBin(r["Source Storage Bin"])) continue;
          const createdBy = Core.normStr(r["Created By"]);
          const confirmedBy = Core.normStr(r["Confirmed by"]);
          const operator = confirmedBy || createdBy;
          if(!INTEREST_OPERATORS.has(operator)) continue;

          const dtVal = (r["Confirmation Date"] || r["Created On"]);
          const tmVal = (r["Confirmation Time"] || r["Created At"]);
          const ts = combineDateTime(dtVal, tmVal);
          if(!ts) continue;

          const procType = Core.normStr(r["Whse Proc. Type"]);
          const category = Core.wtCategory(procType);
          const wo = Core.normStr(r["Warehouse Order"]);

          const srcBin = Core.normStr(r["Source Storage Bin"]);
          const dstBin = Core.normStr(r["Destination Storage Bin"]);
          const srcLane = Core.laneFromStorageBin(srcBin);
          const dstLane = Core.laneFromStorageBin(dstBin);

          events.push({
            dataset_id: datasetId,
            ts: ts.toISOString(),
            day_key: dayKey,
            [EVENTS_OPERATOR_COL]: operator,
            kind: "WT",
            category,
            self_count: false,
            storage_bin: srcBin || null,
            lane: (srcLane===null ? null : srcLane),
            wo_id: wo || null
          });

          // Extra lane for P2P destination (heatmap task)
          if(category==="P2P" && Core.isNonEmptyBin(dstBin) && dstLane!==null){
            events.push({
              dataset_id: datasetId,
              ts: ts.toISOString(),
              day_key: dayKey,
              [EVENTS_OPERATOR_COL]: operator,
              kind: "WT",
              category,
              self_count: false,
              storage_bin: dstBin || null,
              lane: dstLane,
              wo_id: wo || null
            });
          }
        }

        if(!events.length) continue;

        setStatus(`Upload eventi (${label}) — ${events.length} righe…`);
        await insertInChunks("events", events, 1000);
        totalInserted += events.length;
      }

      setStatus(`Completato. Eventi inseriti: ${totalInserted}`, true);
      await loadDatasets();

    }catch(e){
      console.error(e);
      setErr(String(e?.message || e));
      setStatus("Errore");
    }
  });

  (async function boot(){
    try{
      // set initial mode from storage
      const sel = getSel();
      $("selMode").value = sel.mode || "day";
      setStatus("Caricamento…");
      await loadDatasets();
      updateSelSummary();
      setStatus("Pronto.", true);
    }catch(e){
      console.error(e);
      setErr(e.message||String(e));
      setStatus("Errore");
    }
  })();
</script>

</body>
</html>
