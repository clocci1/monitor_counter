<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Monitor Counter — Home</title>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <script src="./app-core.js"></script>

  <style>
    :root{--bg:#0b1220;--card:#111a2e;--border:rgba(255,255,255,.12);--muted:#a9b7d6;--text:#e8eefc;--btn:#6ea8fe;--bad:#ff6b6b;}
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:var(--bg);color:var(--text);}
    header{padding:14px 18px;border-bottom:1px solid var(--border);background:rgba(0,0,0,.2);}
    nav a{color:var(--text);text-decoration:none;margin-right:12px;font-weight:800;}
    .wrap{max-width:1500px;margin:0 auto;padding:16px 18px;}
    .grid{display:grid;grid-template-columns:1fr 520px;gap:12px;align-items:start;}
    @media(max-width:1200px){.grid{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;margin-bottom:12px;}
    .hint{color:var(--muted);font-size:12px;}
    .bad{color:var(--bad);font-size:12px;}
    input,select,button{border-radius:10px;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);padding:10px;}
    button{background:var(--btn);color:var(--bg);border:0;font-weight:900;cursor:pointer;}
    button.secondary{background:rgba(255,255,255,.10);color:var(--text);border:1px solid var(--border);}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:12px;}
    th,td{padding:8px;border-bottom:1px solid var(--border);}
    th{color:var(--muted);text-align:left;font-weight:800;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end;}
    .col{display:flex;flex-direction:column;gap:6px;min-width:240px;}
    .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:rgba(255,255,255,.06);}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace;}
  </style>
</head>
<body>
<header>
  <nav>
    <a href="index.html">Home</a>
    <a href="overview.html">Overview</a>
    <a href="charts.html">Charts</a>
    <a href="score.html">Score</a>
  </nav>
</header>

<div class="wrap">
  <div class="grid">
    <div>
      <div class="card">
        <div style="font-weight:900;">Import PI + WT su Supabase</div>
        <div class="hint">Se l'import fallisce con “permission denied”, devi disattivare RLS o aggiungere policy INSERT su datasets/events.</div>

        <div class="row" style="margin-top:10px;">
          <div class="col">
            <label class="hint">PI (xlsx) — multi-file</label>
            <input id="piFile" type="file" accept=".xlsx,.xls" multiple>
          </div>
          <div class="col">
            <label class="hint">WT (xlsx) — multi-file</label>
            <input id="wtFile" type="file" accept=".xlsx,.xls" multiple>
          </div>
          <div class="col" style="min-width:260px;">
            <label class="hint">Etichetta dataset</label>
            <input id="dsLabel" placeholder="es: 21-01 (AM)">
          </div>
          <div class="col" style="min-width:200px;">
            <button id="importBtn" type="button">Importa</button>
          </div>
        </div>

        <div id="status" class="hint" style="margin-top:10px;">Stato: —</div>
        <div id="err" class="bad" style="margin-top:6px;"></div>
      </div>

      <div class="card">
        <div style="font-weight:900;">Dataset attivo</div>
        <div class="row" style="margin-top:10px;">
          <div class="col" style="min-width:420px;">
            <label class="hint">Seleziona dataset</label>
            <select id="dsSelect"></select>
          </div>
          <div class="col" style="min-width:200px;">
            <button id="setActiveBtn" class="secondary" type="button">Imposta attivo</button>
          </div>
        </div>
        <div class="hint" id="activeInfo" style="margin-top:8px;">—</div>
      </div>
    </div>

    <aside>
      <div class="card">
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;flex-wrap:wrap;">
          <div>
            <div style="font-weight:900;">Dataset presenti</div>
            <div class="hint">Selezione salvata per dataset (localStorage).</div>
          </div>
          <span id="selSummary" class="pill">0 selezionati</span>
        </div>

        <div class="row" style="margin-top:10px;">
          <div class="col" style="min-width:220px;">
            <label class="hint">Vista</label>
            <select id="selMode">
              <option value="days" selected>Giorni</option>
              <option value="weeks">Settimane</option>
              <option value="months">Mesi</option>
            </select>
          </div>
          <div class="col" style="min-width:220px;">
            <label class="hint">Includi</label>
            <select id="selApply">
              <option value="both" selected>PI + WT</option>
              <option value="pi">Solo PI</option>
              <option value="wt">Solo WT</option>
            </select>
          </div>
        </div>

        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;">
          <button id="selAllBtn" class="secondary" type="button">Tutti</button>
          <button id="sel7Btn" class="secondary" type="button">Ultimi 7</button>
          <button id="clearSelBtn" class="secondary" type="button">Reset</button>
        </div>

        <div id="dsDaysWrap" style="margin-top:10px;"></div>
      </div>
    </aside>
  </div>
</div>

<script>
const Core = window.AppCore;
const $ = (id)=>document.getElementById(id);
function setStatus(t){ $('status').textContent = 'Stato: ' + t; }
function setErr(t){ $('err').textContent = t||''; }

async function readFirstSheet(file){
  const ab = await file.arrayBuffer();
  const wb = XLSX.read(ab, {type:'array', cellDates:true});
  const ws = wb.Sheets[wb.SheetNames[0]];
  return XLSX.utils.sheet_to_json(ws, {defval:''});
}

function norm(v){ return (v===null||v===undefined)?'':String(v).trim(); }
function getField(row, names){
  for(const n of names){ if(Object.prototype.hasOwnProperty.call(row,n)) return row[n]; }
  return '';
}
function isNonEmptyBin(v){ const s=norm(v); return s!=='' && s!=='0'; }

function excelDateToYMD(d){
  if(!d) return null;
  if(d instanceof Date && !isNaN(d.getTime())) return {y:d.getFullYear(),m:d.getMonth()+1,day:d.getDate()};
  const dt = new Date(d);
  if(!isNaN(dt.getTime())) return {y:dt.getFullYear(),m:dt.getMonth()+1,day:dt.getDate()};
  return null;
}
function parseTimeToHMS(t){
  if(t===null||t===undefined||t==='') return {h:0,min:0,s:0};
  if(t instanceof Date && !isNaN(t.getTime())) return {h:t.getHours(),min:t.getMinutes(),s:t.getSeconds()};
  if(typeof t==='number' && isFinite(t)){
    const totalSeconds = Math.round(t*24*3600);
    return {h:Math.floor(totalSeconds/3600)%24, min:Math.floor((totalSeconds%3600)/60), s:totalSeconds%60};
  }
  const s=String(t).trim();
  const m=s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if(m) return {h:+m[1],min:+m[2],s:m[3]?+m[3]:0};
  const dt=new Date(s);
  if(!isNaN(dt.getTime())) return {h:dt.getHours(),min:dt.getMinutes(),s:dt.getSeconds()};
  return {h:0,min:0,s:0};
}
function combineDateTime(dateVal, timeVal){
  const ymd=excelDateToYMD(dateVal);
  if(!ymd) return null;
  const hms=parseTimeToHMS(timeVal);
  const dt=new Date(ymd.y, ymd.m-1, ymd.day, hms.h, hms.min, hms.s);
  return isNaN(dt.getTime()) ? null : dt;
}

function piCategory(bin){ return Core.isPickBin(bin) ? 'PI Pick' : 'PI Bulk'; }

async function insertChunk(table, rows, chunk=1000){
  for(let i=0;i<rows.length;i+=chunk){
    const part = rows.slice(i, i+chunk);
    const { error } = await Core.sb.from(table).insert(part);
    if(error) throw new Error(error.message);
  }
}

async function loadDatasetsUI(){
  const ds = await Core.fetchDatasets();
  const sel = $('dsSelect');
  sel.innerHTML = ds.map(d=>`<option value="${d.id}">${d.label} — ${String(d.created_at).slice(0,16).replace('T',' ')}</option>`).join('');
  const active = Core.getActiveDatasetId();
  if(active && ds.some(x=>x.id===active)) sel.value = active;
  updateActiveInfo(ds);
  await renderSelection();
}

function updateActiveInfo(datasets){
  const active = Core.getActiveDatasetId();
  const d = (datasets||[]).find(x=>x.id===active);
  $('activeInfo').textContent = d ? `Attivo: ${d.label} (ID: ${d.id})` : 'Nessun dataset attivo.';
}

function isoWeekKey(dayKey){
  const d = new Date(dayKey+"T00:00:00");
  const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
  const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2,'0')}`;
}
function monthKey(dayKey){
  const d = new Date(dayKey+"T00:00:00");
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
}

function updateSelSummary(){
  const id = Core.getActiveDatasetId();
  if(!id){ $('selSummary').textContent='0 selezionati'; return; }
  const keys = Core.selectionDayKeys(Core.getSelection(id));
  $('selSummary').textContent = keys.length + ' selezionati';
}

async function renderSelection(){
  const active = Core.getActiveDatasetId();
  const wrap = $('dsDaysWrap');
  if(!active){ wrap.innerHTML = '<div class="hint">Imposta un dataset attivo.</div>'; return; }

  const { data, error } = await Core.sb.from('events').select('day_key').eq('dataset_id', active);
  if(error) throw new Error(error.message);

  const dayKeys = Array.from(new Set((data||[]).map(x=>String(x.day_key).slice(0,10)))).sort().reverse();

  const mode = $('selMode').value;
  const apply = $('selApply').value;
  const selObj = Core.getSelection(active);

  if(mode==='days'){
    wrap.innerHTML = `
      <table>
        <thead><tr><th>Giorno</th><th style="text-align:center;">PI</th><th style="text-align:center;">WT</th></tr></thead>
        <tbody>
          ${dayKeys.map(dk=>{
            const s=selObj[dk]||{pi:false,wt:false};
            return `<tr>
              <td class="mono">${Core.fmtDDMMYYYY(dk)}</td>
              <td style="text-align:center;"><input type="checkbox" data-day="${dk}" data-kind="pi" ${s.pi?'checked':''}></td>
              <td style="text-align:center;"><input type="checkbox" data-day="${dk}" data-kind="wt" ${s.wt?'checked':''}></td>
            </tr>`;
          }).join('')}
        </tbody>
      </table>
    `;
    wrap.querySelectorAll('input[type="checkbox"]').forEach(ch=>{
      ch.addEventListener('change', ()=>{
        const dk = ch.getAttribute('data-day');
        const kind = ch.getAttribute('data-kind');
        const sel2 = Core.getSelection(active);
        sel2[dk]=sel2[dk]||{pi:false,wt:false};
        sel2[dk][kind]=ch.checked;
        if(!sel2[dk].pi && !sel2[dk].wt) delete sel2[dk];
        Core.setSelection(active, sel2);
        updateSelSummary();
      });
    });
    updateSelSummary();
    return;
  }

  const groups = new Map();
  for(const dk of dayKeys){
    const gk = (mode==='weeks') ? isoWeekKey(dk) : monthKey(dk);
    if(!groups.has(gk)) groups.set(gk, []);
    groups.get(gk).push(dk);
  }
  const groupKeys = Array.from(groups.keys()).sort().reverse();

  wrap.innerHTML = groupKeys.map(gk=>{
    const days = groups.get(gk).slice().sort();
    return `
      <div style="border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;margin-bottom:10px;background:rgba(255,255,255,.03);">
        <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;">
          <div>
            <div style="font-weight:900;">${mode==='weeks' ? 'Settimana ' + gk : 'Mese ' + gk}</div>
            <div class="hint">Giorni: ${days.length} (${Core.fmtDDMMYYYY(days[0])} → ${Core.fmtDDMMYYYY(days[days.length-1])})</div>
          </div>
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
            <label class="pill"><span class="hint">PI</span><input type="checkbox" data-group="${gk}" data-gkind="pi"></label>
            <label class="pill"><span class="hint">WT</span><input type="checkbox" data-group="${gk}" data-gkind="wt"></label>
          </div>
        </div>
      </div>
    `;
  }).join('');

  wrap.querySelectorAll('input[data-group]').forEach(ch=>{
    ch.addEventListener('change', ()=>{
      const gk = ch.getAttribute('data-group');
      const kind = ch.getAttribute('data-gkind');
      const checked = ch.checked;
      const days = groups.get(gk) || [];
      const sel2 = Core.getSelection(active);
      for(const dk of days){
        sel2[dk]=sel2[dk]||{pi:false,wt:false};
        if(kind==='pi') sel2[dk].pi = checked && (apply==='both' || apply==='pi');
        if(kind==='wt') sel2[dk].wt = checked && (apply==='both' || apply==='wt');
        if(!sel2[dk].pi && !sel2[dk].wt) delete sel2[dk];
      }
      Core.setSelection(active, sel2);
      updateSelSummary();
    });
  });
  updateSelSummary();
}

$('selMode').addEventListener('change', ()=>loadDatasetsUI().catch(e=>setErr(e.message)));
$('selApply').addEventListener('change', ()=>loadDatasetsUI().catch(e=>setErr(e.message)));

$('setActiveBtn').addEventListener('click', ()=>{
  Core.setActiveDatasetId($('dsSelect').value);
  loadDatasetsUI().catch(e=>setErr(e.message));
});

$('clearSelBtn').addEventListener('click', async ()=>{
  const id=Core.getActiveDatasetId(); if(!id) return;
  Core.setSelection(id, {});
  updateSelSummary();
  await loadDatasetsUI();
});

$('selAllBtn').addEventListener('click', async ()=>{
  try{
    const id=Core.getActiveDatasetId(); if(!id) return;
    const { data, error } = await Core.sb.from('events').select('day_key').eq('dataset_id', id);
    if(error) throw new Error(error.message);
    const days = Array.from(new Set((data||[]).map(x=>String(x.day_key).slice(0,10))));
    const out={}; for(const dk of days) out[dk]={pi:true,wt:true};
    Core.setSelection(id, out);
    updateSelSummary();
    await loadDatasetsUI();
  } catch(e){ setErr(e.message); }
});

$('sel7Btn').addEventListener('click', async ()=>{
  try{
    const id=Core.getActiveDatasetId(); if(!id) return;
    const { data, error } = await Core.sb.from('events').select('day_key').eq('dataset_id', id);
    if(error) throw new Error(error.message);
    const days = Array.from(new Set((data||[]).map(x=>String(x.day_key).slice(0,10)))).sort().reverse().slice(0,7);
    const out={}; for(const dk of days) out[dk]={pi:true,wt:true};
    Core.setSelection(id, out);
    updateSelSummary();
    await loadDatasetsUI();
  } catch(e){ setErr(e.message); }
});

$('importBtn').addEventListener('click', async ()=>{
  try{
    setErr('');
    const piFiles = Array.from($('piFile').files||[]);
    const wtFiles = Array.from($('wtFile').files||[]);
    const label = ( $('dsLabel').value || '' ).trim() || ('Import ' + new Date().toISOString().slice(0,16).replace('T',' '));
    if(!piFiles.length || !wtFiles.length){ setErr('Carica PI e WT.'); return; }

    setStatus('Lettura Excel…');
    let piRows=[]; for(const f of piFiles) piRows.push(...await readFirstSheet(f));
    let wtRows=[]; for(const f of wtFiles) wtRows.push(...await readFirstSheet(f));

    const events=[];
    let minDay=null, maxDay=null;

    // PI mapping from your sample header
    for(const r of piRows){
      const counter = norm(getField(r, ['Counter']));
      if(!counter) continue;
      const dt = combineDateTime(getField(r, ['Count Date']), getField(r, ['Count Time']));
      if(!dt) continue;
      const dayKey = Core.dayKeyFromDate(dt);

      const bin = norm(getField(r, ['Storage Bin']));
      const createdBy = norm(getField(r, ['Created By']));
      const selfCount = (counter && createdBy && counter===createdBy);

      events.push({
        dataset_id: null,
        ts: dt.toISOString(),
        day_key: dayKey,
        src_operator: counter,
        eff_operator: counter,
        kind: 'PI',
        category: Core.isPickBin(bin) ? 'PI Pick' : 'PI Bulk',
        self_count: !!selfCount,
        storage_bin: bin || null,
        lane: Core.laneFromBin(bin) || null,
        wo_id: norm(getField(r, ['Warehouse Order'])) || null,
        meta: { created_by: createdBy || null }
      });

      if(!minDay || dayKey < minDay) minDay=dayKey;
      if(!maxDay || dayKey > maxDay) maxDay=dayKey;
    }

    // WT mapping from your sample header
    for(const r of wtRows){
      const srcBin = norm(getField(r, ['Source Storage Bin']));
      if(!isNonEmptyBin(srcBin)) continue;

      const proc = norm(getField(r, ['Whse Proc. Type']));
      const cat = Core.wtCategory(proc);

      const wo = norm(getField(r, ['Warehouse Order']));
      const destBin = norm(getField(r, ['Dest. Stor. Bin']));
      const qty = getField(r, ['Act.Qty Dest. Alt.Un']);

      const confirmedBy = norm(getField(r, ['Confirmed by','Confirmed By']));
      const createdBy = norm(getField(r, ['Created By']));
      const srcOp = confirmedBy || createdBy;
      if(!srcOp) continue;

      // Use Confirmation Date/Time if present, else Created On/At
      const dt = combineDateTime(
        getField(r, ['Confirmation Date','Created On']),
        getField(r, ['Confirmation Time','Created At'])
      );
      if(!dt) continue;

      const dayKey = Core.dayKeyFromDate(dt);
      const baseMeta = {
        proc_type: proc || null,
        confirmed_by: confirmedBy || null,
        created_by: createdBy || null,
        act_qty: (typeof qty === 'number' || typeof qty === 'string') ? (Number(qty) || 0) : 0,
        source_bin: srcBin || null,
        dest_bin: destBin || null
      };

      events.push({
        dataset_id: null,
        ts: dt.toISOString(),
        day_key: dayKey,
        src_operator: srcOp,
        eff_operator: srcOp,
        kind: 'WT',
        category: cat,
        self_count: false,
        storage_bin: srcBin || null,
        lane: Core.laneFromBin(srcBin) || null,
        wo_id: wo || null,
        meta: Object.assign({ role:'src' }, baseMeta)
      });

      // For P2P: also add dest event to support heatmap distance/aisle
      if(cat==='P2P' && isNonEmptyBin(destBin)){
        events.push({
          dataset_id: null,
          ts: dt.toISOString(),
          day_key: dayKey,
          src_operator: srcOp,
          eff_operator: srcOp,
          kind: 'WT',
          category: cat,
          self_count: false,
          storage_bin: destBin || null,
          lane: Core.laneFromBin(destBin) || null,
          wo_id: wo || null,
          meta: Object.assign({ role:'dest' }, baseMeta)
        });
      }

      if(!minDay || dayKey < minDay) minDay=dayKey;
      if(!maxDay || dayKey > maxDay) maxDay=dayKey;
    }

    if(!events.length){ setErr('Nessun evento generato.'); return; }

    setStatus('Creazione dataset…');
    const { data: ds, error: dsErr } = await Core.sb
      .from('datasets')
      .insert([{ label, start_date:minDay, end_date:maxDay, notes:null }])
      .select('id')
      .single();
    if(dsErr) throw new Error(dsErr.message);

    const datasetId = ds.id;
    for(const e of events) e.dataset_id = datasetId;

    setStatus('Inserimento eventi… (' + events.length + ')');
    await insertChunk('events', events, 1000);

    Core.setActiveDatasetId(datasetId);

    const out={};
    for(const e of events) out[e.day_key] = {pi:true, wt:true};
    Core.setSelection(datasetId, out);

    setStatus('Completato.');
    await loadDatasetsUI();
  } catch(e){
    console.error(e);
    setErr(e.message || String(e));
    setStatus('Errore');
  }
});

(async function boot(){
  try{
    setStatus('Caricamento…');
    await loadDatasetsUI();
    setStatus('Pronto.');
  } catch(e){
    setErr(e.message);
    setStatus('Errore');
  }
})();
</script>
</body>
</html>
